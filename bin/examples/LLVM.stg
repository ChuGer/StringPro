group LLVM;

// map operators to LLVM IR instructions
opToInstr ::= [ 
        "+":"add",
        "-":"sub",
        "*":"mul",
        "/":"sdiv",
        "==":"icmp eq",
        "!=":"icmp ne",
        "<":"icmp slt",
        ">":"icmp sgt",
        "<=":"icmp sle",
        ">=":"icmp sge"
]

llvmType ::= [ 
        "Int":"i32", 
        "void":"void",
        "String":"i8*"
        ]

program(globals,functions,strings) ::= <<
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32"
target triple = "i386-mingw32"
declare i32 @printf(i8 *, ...) nounwind
declare i8* @gets(i8*)
declare i32 @atoi(i8*) nounwind readonly

<strings:{s | @.str<s.reg> = private constant [<s.len> x i8] c<s.s>, align 1}; separator="\n">
<globals; separator="\n">
<functions; separator="\n">
>>


args(args) ::=  <<<args; separator=", "> >>

globalVars(vars) ::= <<
<vars; separator="\n">
>>

vars(vars) ::= <<
<vars; separator="\n">
>>

fun_decl(type, name, args, locals,stats) ::= <<
define <if(type)><type><else>void<endif> @<name>(<args:{arg | <arg.type> %<arg.id>_arg}; separator=", ">) {
	<args:{arg | %<arg.id> = alloca <arg.type>}; separator="\n">
	<args:{arg | store <arg.type> %<arg.id>_arg, <arg.type>* %<arg.id>}; separator="\n">
	<locals; separator="\n">
	<stats; separator="\n">
}
>>

return_st(ret_val) ::= <<
<ret_val>
ret i32 %r<ret_val.reg>
>>

def_arg(id, type) ::= "<llvmType.(type)> %<id>_arg"

def_var(id, type) ::= "%<id> = alloca <llvmType.(type)>"

def_glob(id,type) ::=  "@<id> = global <llvmType.(type)> 0"


block(locals={$slist::locals}, stats={$slist::stats}) ::= <<
    <locals; separator="\n">
    <stats; separator="\n">
>>

body(ops, ret) ::= <<
{
  <ops; separator="\n">
  <ret>
}
>>

main_decl(locals={$slist::locals}, stats={$slist::stats}) ::= <<
    define i32 @main() {
    <locals; separator="\n">
    <stats; separator="\n">
    }
>>

type_int() ::= "i32"

type_char() ::= "char"

type_string() ::= "internal constant [4 x i8]"

type_user_object(name) ::= "<name>"

parameter(type,name) ::= "<type> %<name>"

statement(expr) ::= "<expr>;"

statementList(locals,stats) ::= <<
{
    <locals; separator="\n">
    <stats; separator="\n">
}<\n>
>>

for_list_op (type, id, listId, locals, stats) ::= <<
for (<type> <id> : <listId>) {
    <locals; separator="\n">
    <stats; separator="\n">
}  
>>
            
while_op(bool_cond,locals,stats) ::= <<
while (<bool_cond>) {
    <locals; separator="\n">
    <stats; separator="\n">
}
>>


if_op(cond, stat1, stat2, tmp) ::= <<
<cond>
br i1 %r<cond.reg>, label %true<tmp>, label %false<tmp>
true<tmp>:
<stat1>
<if(stat2)>
br label %end<tmp>
false<tmp>:
<stat2>
end<tmp>:
<else>
false<tmp>:
<endif>
>>

for_op(cond, stat,tmp) ::= <<
%i<cond.id> = alloca i32
store i32 0, i32* %i<cond.id>
%ii<cond.id> = alloca i32
store i32 <cond.less>, i32* %ii<cond.id>
br label %loop<tmp>
loop<tmp>:
    <cond>
    br i1 %r<cond.reg>, label %start<tmp>, label %end<tmp>
start<tmp>:
    <stat>
	  %aa<cond.id> = load i32* %i<cond.id>, align 4  
	  %bb<cond.id> = add nsw i32 %aa<cond.id>, 1      
	  store i32 %bb<cond.id>, i32* %i<cond.id>, align 4
    br label %loop<tmp>
end<tmp>:
>>

for_expr(id={getreg()}, less={$INT.text}, reg={getreg()}) ::= <<
%b1 = load i32* %i<id>, align 4  
%b2 = load i32* %ii<id>, align 4  
%r<reg> = icmp slt i32 %b1, %b2
>>

bop(reg, op, a, b) ::= <<
<a>
<b>
%r<reg> = <opToInstr.(op)> i32 %r<a.reg>, %r<b.reg>
>>

else_block(locals, stats) ::= <<
 else {
	<locals; separator="\n">
	<stats; separator="\n">    
}
>>

listInit(name,params) ::= <<List <name> = new ArrayList();
<params>
>>
listParam(listName,val) ::= <<<listName>.add(<val>);

>> 

assign(id, rhs) ::= <<
<rhs>
store i32 %r<rhs.reg>, i32* %<id>
>>

def_assign(type, id, rhs) ::= <<
%<id> = alloca <llvmType.(type)>
<rhs>
store <llvmType.(type)> %r<rhs.reg>, <llvmType.(type)>* %<id>
>>

equals(left,right) ::= "<left> == <right>"

lessThan(left,right) ::= "<left> \< <right>"

add(left,right) ::= "<left> + <right>"

addSign(left,sign,right) ::= "<left> <sign> <right>"

refVar(id) ::= "<id>"

iconst(value) ::= "<value>"

inbrac(value) ::= "(<value>)"

addExpr(sign,right) ::= "<sign><right>"

funCall(reg, funName, funArgs,ret) ::= <<
<funArgs; separator="\n">
%r<reg> = call <llvmType.(ret)>(<funArgs:{i32}; separator=",">)* @<funName>(<funArgs:{i32 %r<it.reg>}; separator=", ">)
>>

outOp(format, params) ::= <<
<format>
<if(params)>
<params; separator="\n">
call i32 (i8*, ...)* @printf(i8* %r<format.reg>, <params:{<llvmType.(it.type)> %r<it.reg>}; separator=", ">)
<else>
call i32 (i8*, ...)* @printf(i8* %r<format.reg>)
<endif>
>>

readOp(id) ::= <<
%tmp1 = load i8** %<id>
%tmp2 = call i8* @gets(i8* %tmp1) nounwind
store i8* %tmp2, i8** %<id>
>>

toIntOp(id,reg) ::= <<
%t1 = load i8** %<id>
%r<reg> = call i32 @atoi(i8* %t1) nounwind readonly
>>

array_type(type) ::= "[<type.sizeExpr> x i32]"

string_type(s) ::= "[<s> x i8]"

load_var(reg, id, type) ::= "%r<reg> = load <llvmType.(type)>* %<id>"

int(reg, v, type) ::= "%r<reg> = add i32 <v>, 0"

// s needed by C target, sreg needed by llvm target
string(reg, s, sreg, len, type) ::= "%r<reg> = getelementptr [<len> x i8]* @.str<reg>, i64 0, i64 0"